// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user_movie.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUserMovie = `-- name: CreateUserMovie :one
INSERT INTO user_movies (
    user_id, movie_id, rating, review, watchlist, watched, favorited
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING user_id, movie_id, rating, review, watchlist, watched, favorited, created_at
`

type CreateUserMovieParams struct {
	UserID    int32          `json:"user_id"`
	MovieID   int32          `json:"movie_id"`
	Rating    pgtype.Numeric `json:"rating"`
	Review    pgtype.Text    `json:"review"`
	Watchlist pgtype.Bool    `json:"watchlist"`
	Watched   pgtype.Bool    `json:"watched"`
	Favorited pgtype.Bool    `json:"favorited"`
}

func (q *Queries) CreateUserMovie(ctx context.Context, arg CreateUserMovieParams) (UserMovies, error) {
	row := q.db.QueryRow(ctx, createUserMovie,
		arg.UserID,
		arg.MovieID,
		arg.Rating,
		arg.Review,
		arg.Watchlist,
		arg.Watched,
		arg.Favorited,
	)
	var i UserMovies
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.Review,
		&i.Watchlist,
		&i.Watched,
		&i.Favorited,
		&i.CreatedAt,
	)
	return i, err
}

const getUserMovie = `-- name: GetUserMovie :one
SELECT user_id, movie_id, rating, review, watchlist, watched, favorited, created_at FROM user_movies
WHERE user_id = $1 AND movie_id = $2
LIMIT 1
`

type GetUserMovieParams struct {
	UserID  int32 `json:"user_id"`
	MovieID int32 `json:"movie_id"`
}

func (q *Queries) GetUserMovie(ctx context.Context, arg GetUserMovieParams) (UserMovies, error) {
	row := q.db.QueryRow(ctx, getUserMovie, arg.UserID, arg.MovieID)
	var i UserMovies
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.Review,
		&i.Watchlist,
		&i.Watched,
		&i.Favorited,
		&i.CreatedAt,
	)
	return i, err
}

const listUserMovies = `-- name: ListUserMovies :many
SELECT user_id, movie_id, rating, review, watchlist, watched, favorited, created_at FROM user_movies
WHERE user_id = $1
ORDER BY movie_id
LIMIT $2
OFFSET $3
`

type ListUserMoviesParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserMovies(ctx context.Context, arg ListUserMoviesParams) ([]UserMovies, error) {
	rows, err := q.db.Query(ctx, listUserMovies, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserMovies
	for rows.Next() {
		var i UserMovies
		if err := rows.Scan(
			&i.UserID,
			&i.MovieID,
			&i.Rating,
			&i.Review,
			&i.Watchlist,
			&i.Watched,
			&i.Favorited,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserMovie = `-- name: UpdateUserMovie :one
UPDATE user_movies
SET 
    rating = COALESCE($3, rating), 
    review = COALESCE($4, review), 
    watchlist = COALESCE($5, watchlist), 
    watched = COALESCE($6, watched), 
    favorited = COALESCE($7, favorited)
WHERE user_id = $1 AND movie_id = $2
RETURNING user_id, movie_id, rating, review, watchlist, watched, favorited, created_at
`

type UpdateUserMovieParams struct {
	UserID    int32          `json:"user_id"`
	MovieID   int32          `json:"movie_id"`
	Rating    pgtype.Numeric `json:"rating"`
	Review    pgtype.Text    `json:"review"`
	Watchlist pgtype.Bool    `json:"watchlist"`
	Watched   pgtype.Bool    `json:"watched"`
	Favorited pgtype.Bool    `json:"favorited"`
}

func (q *Queries) UpdateUserMovie(ctx context.Context, arg UpdateUserMovieParams) (UserMovies, error) {
	row := q.db.QueryRow(ctx, updateUserMovie,
		arg.UserID,
		arg.MovieID,
		arg.Rating,
		arg.Review,
		arg.Watchlist,
		arg.Watched,
		arg.Favorited,
	)
	var i UserMovies
	err := row.Scan(
		&i.UserID,
		&i.MovieID,
		&i.Rating,
		&i.Review,
		&i.Watchlist,
		&i.Watched,
		&i.Favorited,
		&i.CreatedAt,
	)
	return i, err
}
